---
description: Protobox project development - apps, components, views, config
globs: "**/src/**/*"
alwaysApply: false
---

# Protobox Project Development

## Structure

```
src/
  apps/       # PascalCase dirs: App.tsx → Name.tsx, Name.scss, main.tsx, config.ts, context.tsx
  components/ # Name/v1/Name.tsx + Name.scss; use v1, v2 for versions
  views/      # Name/v1/Name.tsx + Name.scss + NameData.ts; one view per app
  assets/     # Images, fonts (jpg, otf, etc.) — copied to build/assets/, served at /assets/
  static/     # Shared static/mock data (import via @/static)
  @types/     # _global/ (all apps), {{AppName}}/ (per-app, PascalCase)
```

## Naming

- All entity directories (apps, components, views, types) use **PascalCase**: `Chart`, `DemoView`, `Card`.
- App files are named after the app: `Chart.tsx`, `Chart.scss` (not `App.tsx`).
- Component/view files are named after the entity: `Card.tsx`, `ChartView.tsx`.
- CSS classes use **BEM kebab-case**: `.chart-app`, `.card_version-v1`, `.demo-view`. Use `bem()` from `protobox/bem` for root `className`; naming: `Block__element_modifier-value`.
- `main.tsx` and `config.ts` keep their generic names (entry point and config).

## Apps

- Each app is isolated. `config.ts` has `title`, `description`, `parameters`.
- Use params: `import { useProtoParams } from 'protobox/useProtoParams'` then `const params = useProtoParams()`
- No inline styles; use SCSS files.

## Parameters

Use `protobox/parameters` in app `config.ts`:

```ts
paramBoolean("key", "Label", true)
paramNumber("key", "Label", 0, { min, max, step })
paramString("key", "Label", "")
paramOption("key", "Label", "default", [{ value, label }])
paramOptionMulti("key", "Label", [], [{ value, label }])
```

Parameters are only for apps. Components and views do not have parameters or config files.

## View Data Layer

Each view has a `{ViewName}Data.ts` file alongside it (e.g., `DemoView/v1/DemoViewData.ts`):

- Exports `defaultData` (static defaults so the view works standalone), a `Data` type, and an optional `use{ViewName}Data()` hook.
- The hook accepts a context hook and returns wired-up data with callbacks.
- Views are pure presentation: accept `data` prop with a default, no hooks or context calls inside.
- Apps wire data by calling the hook and passing the result to the view.

## Assets

Place images, fonts, etc. in `src/assets/`. Use absolute path `/assets/...` (no import — avoids duplication across apps):

- **TSX:** `<img src="/assets/images/logo.jpg" />`
- **SCSS:** `url('/assets/fonts/MyFont.otf')`, `url('/assets/images/bg.jpg')`

## Imports

- Use hard-coded versioned paths: `import { Card } from '@/components/Card/v1/Card'`.
- Static/mock data: `import { ... } from '@/static'`.
- One view per app. Always define an interface for components and views.

## Context

```tsx
const { Provider, useValue } = createProtoContext({ name, initialState, useImmer });
// Use Provider at app root; useValue() in children.
```

## Types Isolation

- `@types/global/` — any app can import (Window augmentation)
- `@types/{{AppName}}/` — only that app should import; keeps app-specific types scoped

## Do Not

- Use heavy state frameworks; keep data in props, context, or hooks.
- Import other apps; each app is self-contained.
- Duplicate shared components; reference from `@/components`, `@/views`.
- Add parameters, config.ts, or main.tsx to components or views.
